### 第三章 代码块

##### 块（block）

* 块可以定义在大括号中（单行），也可以放在do ... end关键字中（多行）。
* **只有在调用一个方法时才可以定义一个块**，块会被直接传递给这个方法，然后该方法可以用**yield**这个关键字回调这个块
* 块可以有自己的参数，块中最后一行代码执行结果将会被作为返回值（和方法一样）
```ruby
# Todo
# example
```
* 如果在block_given?()返回false时使用了yield，会得到一个运行时错误。
* 绑定：即执行环境（局部变量、实力变量、self等）
* 块的要点在于它们是完整的，可以立即执行。它们既包含代码，也包含一组绑定。
* 当创建块时，会获取到局部绑定，把块连同它自己的绑定传给一个方法。
* 一个块可以获取局部绑定，并一直带着它们。

###### 作用域（scope）

* 如果一个对象调用**相同对象**中的另一个方法，那么实力变量在调用过程中始终存在于作用域中。
* 局部变量总是会掉出作用域（这就是它们被称为“局部”的元婴）。
* 程序会在三个地方关闭前一个作用域，同时打开一个新的作用域（**作用域门**）：
  * 类定义（**class**关键字为标志）
  * 模块定义（**module**关键字为标志）
  * 方法（**def**关键字为标志）
* **class/module**和**def**之间还有点微妙区别：在类和模块定义中的代码**会被立即执行**；相反，方法定义中的代码**只有在方法被调用时被执行**

* Proc.new、lamda、proc的区别：
  * lamda参较严格
  * lamda的return是从块中返回

##### 其他

* 全局变量（$var）在系统的任何部分都可以修改它们，几乎无法追踪谁把它们改成了什么，所以，**如非必要，尽可能少使用全局变量**
* 顶级实例变（在任何方法，类，模块外的@var），它是顶级对象main的实例变量，只要在main对象扮演self时，就可以访问顶级实例变量，但其他对象成为self时，顶级实例变量就退出作用域。由于不想全局变量那么有全局性，一般认为顶级实例变量比全局变量更安全。
