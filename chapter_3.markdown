### 第三章 代码块

##### 块（block）

* 块可以定义在大括号中（单行），也可以放在do ... end关键字中（多行）。
* **只有在调用一个方法时才可以定义一个块**，块会被直接传递给这个方法，然后该方法可以用**yield**这个关键字回调这个块
* 块可以有自己的参数，块中最后一行代码执行结果将会被作为返回值（和方法一样）
```ruby
# Todo
# example
```
* 如果在block_given?()返回false时使用了yield，会得到一个运行时错误。
* 绑定：即执行环境（局部变量、实力变量、self等）
* 块的要点在于它们是完整的，可以立即执行。它们既包含代码，也包含一组绑定。
* 当创建块时，会获取到局部绑定，把块连同它自己的绑定传给一个方法。
* 一个块可以获取局部绑定，并一直带着它们。

###### 作用域（scope）

* 如果一个对象调用**相同对象**中的另一个方法，那么实力变量在调用过程中始终存在于作用域中。
* 局部变量总是会掉出作用域（这就是它们被称为“局部”的元婴）。
* 程序会在三个地方关闭前一个作用域，同时打开一个新的作用域（**作用域门**）：
  * 类定义（**class**关键字为标志）
  * 模块定义（**module**关键字为标志）
  * 方法（**def**关键字为标志）
* **class/module**和**def**之间还有点微妙区别：在类和模块定义中的代码**会被立即执行**；相反，方法定义中的代码**只有在方法被调用时被执行**

###### 可调用对象
* Ruby中绝大多数东西都是对象，但是**块不是对象**。
* 一个Proc就是一个转换成对象的块，可以把块传给`Proc.new`方法来创建一个Proc。之后用`Proc#call`方法来执行这由块转换而来的对象（这种技术成为**延迟执行**）：
```ruby
inc = Proc.new { |x| x + 1 }
# more
inc.call(2) # => 3

# lambda
dec = lambda { |x| x - 1 }
dec.class # Proc
dec.call(2) # => 1
```
* 在方法的参数列表中添加**最后一个以&开头的参数**，就能把块附加到一个绑定上了（该参数上）。

* &操作符的意义是，这是一个Proc对象，我想把它当做一个块来使用；简单的去掉&，就能再次得到一个Proc对象。（以&符号开头的为块，去掉该符（&）就变对象）

* 通过`Proc.new()`方法、`Method#to_proc()`方法和**&**操作符可将一种可调用对象转换为另一种可调用对象：

```ruby
# example code
```

* 可调用对象的区别：

  * 块：虽然不是真正的对象，但是是可调用的；在定义它们的作用域中执行；**`return`语句从定义可调用对象的原始上下文中返回**；对于传入参数数目处理宽松。
  
  * proc: Proc类的对象，跟块一样，也在定义自身的作用域中执行；**`return`语句从定义可调用对象的原始上下文中返回**；对于传入参数数目处理宽松。
  
  * lambda：也是Proc类对象，**和普通proc对象有些微区别**；它和块、proc一样都是闭包，因此也在定义自身的作用域中执行；**`return`语句从可调用对象中返回**；对于传入参数数目处理严格（与方法相比，某些极端情况下略为宽松）。
  
  * 方法：**绑定于对象，在对象所在的作用域中执行**；可以和某个作用域解绑定，然后再绑定到另一个对象的作用域上；对于传入参数数目处理最严格。

##### 其他

* 全局变量（$var）在系统的任何部分都可以修改它们，几乎无法追踪谁把它们改成了什么，所以，**如非必要，尽可能少使用全局变量**
* 顶级实例变（在任何方法，类，模块外的@var），它是顶级对象main的实例变量，只要在main对象扮演self时，就可以访问顶级实例变量，但其他对象成为self时，顶级实例变量就退出作用域。由于不想全局变量那么有全局性，一般认为顶级实例变量比全局变量更安全。
